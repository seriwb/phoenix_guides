Phoenixは、サーバサイドMVCパターンを実装するためにElixirで書かれたWebフレームワークです。その構成要素と概念の多くは、Ruby on RailsやPythonのDjangoのような、他のWebフレームワークの経験を持つ私たちに馴染みのあるものだと思います。

Phoenixは、開発者に高い生産性を与えつつ、アプリケーションがハイパフォーマンスとなるように設計されています。また、リアルタイム機能を実現するためのチャネル（Channels）や、燃え盛る炎のようなスピードをだすために事前コンパイルされるテンプレート（Templates）のような、興味深くて新しい、ひねりのある仕組みをいくつか持っています。

もしあなたがすでにElixirに精通しているのであれば、最高です！そうでなくても、Elixirを学ぶための場所はいくつかあります。[Elixirガイド](http://elixir-lang.org/getting-started/introduction.html)は学び始める場所として最適です。また、私たちも[ElixirとErlangの学習ガイド](http://www.phoenixframework.org/docs/learning-elixir-and-erlang)に役立つ情報をまとめています。

この入門ガイドの目的は、Phoenixを構成するパーツとPhoenixがサポートするレイヤーについて、簡潔かつ高レベルな概要をお伝えすることにあります。

### Phoenix

Phoenixは、モジュール構造で、かつ柔軟であるようにデザインされた多重レイヤーシステムの最上位レイヤーになります。他のレイヤーには、このPhoenixの概要のすぐ後で言及する予定の、PlugとEctoが含まれます。ErlangのHTTPサーバであるCowboyは、PlugとPhoenixの基盤として機能しますが、私たちがこのガイドで直接Cowboyの説明をすることはありません。

Phoenixは、Webアプリケーションを構築するために独自の目的や役割を持った、いくつかの個別パーツで構成されています。これらすべてについて、ガイド全体を通して深く解説していきますが、以下に簡単な内容を記載します。

- エンドポイント
  - ルータに処理を引き継ぐまで、リクエストのすべての側面を処理する
  - すべてのリクエストに適用するPlugの主要なセットを提供する
  - 指定されたルータにリクエストを割り当てる
- ルータ
  - 受け取ったリクエストを解析し、適切なコントローラ/アクションに、必要に応じてパラメータと共に割り当てる
  - リソースへのルートパスとURLを生成するヘルパーを提供する
  - パイプラインという名前で定義された機能を使って、リクエストを渡すことができる
  - パイプライン
    - ルートのセットで、Plugグループが簡単に利用できるようにする
- コントローラ
  - リクエストを処理する、アクションと呼ばれる機能を提供する
  - アクション
    - データを準備し、ビューに渡す
    - ビュー経由でレンダリングを実行する
    - リダイレクトを行う
- ビュー
  - テンプレートをレンダリングする
  - プレゼンテーション層として振る舞う
  - テンプレートで利用可能な、プレゼンテーション用のデータを装飾するヘルパー関数を定義する
- テンプレート
  - テンプレートは顔文字表現のようなものだ
  - テンプレートは事前コンパイルされ、高速に動作する
- チャネル
  - 簡単にリアルタイム通信用のソケットを管理する
  - チャネルは、チャネルが永続コネクションとの双方向通信を許可していることを除いて、コントローラに類似している
- PubSub
  - チャネルレイヤーの下にあり、クライアントはトピックを購読（サブスクライブ）することができる
  - サードパーティのpubsubインテグレーションのために、基底となるpubsubアダプタを抽象化する

### プラグ（Plug）

[Plug](https://hexdocs.pm/plug/)は、Webアプリケーションを作るために利用する、組み立て可能なモジュールを構築するための仕様です。プラグは、その仕様によって作られた、再利用可能なモジュール、または関数です。それらは、リクエストヘッダの解析やロギングのように、別個の動作を提供します。Plug APIは小さく、一貫しているため、複数のプラグを定義し、パイプラインのようにセットした順で実行することができます。それらは、プロジェクト内、または別のプロジェクトで再利用することもできます。

プラグには、認証からパラメータの事前処理まで、ほぼ全ての処理を記述することができます。レンダリングでさえ記述可能です。

Phoenixは全般的に、プラグによって大きなアドバンテージを得ています。ルータとコントローラが特にそうです。

プラグで最も重要なことの一つは、それが最終的に私たちのユーザーにアプリケーションコンテンツを配信するHTTPサーバへのアダプタを提供しているということです。現在のところプラグは、[99s](http://ninenines.eu/)のLoïc HoguinによってErlangで書かれたWebサーバである[Cowboy](https://github.com/ninenines/cowboy)のアダプタのみ提供しています。

より詳しい内容については、[Plugガイド](http://www.phoenixframework.org/docs/understanding-plug)をご覧ください。


### Ecto

[Ecto](http://hexdocs.pm/ecto)は、クエリ組み立てツールと、データベースラッパーを統合したElixirのための言語です。Ectoを使うことで、異なるデータベースへのRead/Write、ドメインデータの作成、型安全な方法での複雑なクエリ記述、SQLインジェクションを含む攻撃ベクトルからの保護など、多くのことができます。

Ectoは、4つの主要な抽象概念を中心に作られています：

* Repo - リポジトリは個々のデータベースへの接続を表します。全てのデータベース操作は、リポジトリを介して行われます。

* Model - モデルはデータ定義です。テーブル名やフィールドだけでなく、各フィールドの型を定義します。またモデルは、モデル間の関係も定義します。

* Query - クエリは、モデルとリポジトリの両方を一緒に結びつけます。これにより私たちは、リポジトリからデータをエレガントに取得し、モデルにデータをキャストすることができます。

* Changeset - チェンジセットは、アプリケーションがモデルデータを使用する前に、モデルデータに実行する必要のある変換内容を宣言します。これらは、型変換、検証など多数の要素を含みます。

新しく作成したPhoenixのアプリケーションは、デフォルトでは、PostgreSQLのストレージに対するEctoを使用します。
